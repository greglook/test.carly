(ns test.carly.report
  "Integration code for wedding generative `test.check` functions and
  `clojure.test` assertion macros."
  (:require
    [clojure.test :as ctest]
    [puget.printer :as puget]))


; TODO: affordance for setting pretty-printer handlers


;; ## Helper Functions

(defmacro capture-reports
  "Capture any clojure.test reports generated by the body. Returns a vector
  containing the evaluated result, followed by a vector of reports."
  [& body]
  `(let [reports# (atom [])]
     [(binding [ctest/report (partial swap! reports# conj)]
        ~@body)
      @reports#]))


(defn publish!
  "Publish a collection of reports to clojure.test."
  [reports]
  (run! ctest/report reports))


(defn wrap-report-check
  "Wrap the given sequence of forms such that it returns false if there is a
  failed clojure.test assertion in the body. If there are no assertions,
  returns the result of evaluating the body."
  [body]
  `(let [[result# reports#] (capture-reports ~@body)]
     (publish! reports#)
     (if (empty? reports#)
       result#
       (not (some (comp #{:fail :error} :type) reports#)))))



;; ## Report Methods

(defmethod ctest/report ::trial-start
  [report]
  (ctest/with-test-out
    (newline)
    ; TODO: better formatting
    (printf "Starting%s trial with %d ops%s...\n"
            (if (< 1 (:repetitions report))
              (str " " (:repetitions report) "x")
              "")
            (:op-count report)
            (if (< 1 (:concurrency report))
              (str " across " (:concurrency report) " threads")
              ""))))


(defmethod ctest/report ::test-start
  [report]
  ; no-op
  ,,,)


(defmethod ctest/report ::run-ops
  [report]
  ; TODO: only if verbose
  (ctest/with-test-out
    (printf "Ran %d ops%s in %.2f ms\n"
            (:op-count report)
            (if (< 1 (:concurrency report))
              (str " across " (:concurrency report) " threads")
              "")
            (:elapsed report))))


#_ ; search returns:
{:world valid-world
 :threads 1
 :futures n
 :visited @visited
 :reports @reports
 :elapsed elapsed}


; TODO: update nested assertion pass/fail/error counts?
; TODO: option to show valid linearization
(defmethod ctest/report ::test-pass
  [report]
  (ctest/with-test-out
    (ctest/inc-report-counter :pass)
    (printf "Found valid worldline among %s futures in %.2f ms after visiting %d worlds\n"
            (:futures report)
            (:elapsed report)
            (:visited report))))


(defmethod ctest/report ::test-fail
  [report]
  (ctest/with-test-out
    (ctest/inc-report-counter :fail)
    (printf "Exhausted valid worldlines among %s futures in %.2f ms after visiting %d worlds\n"
            (:futures report)
            (:elapsed report)
            (:visited report))))


(defmethod ctest/report ::trial-pass
  [report]
  ; green check mark at end of dots?
  ; TODO: something with 'elapsed'?
  )


(defmethod ctest/report ::trial-fail
  [report]
  ; red X at end of dots?
  ; TODO: something with 'elapsed'?
  )


;; Report a successful generative test summary.
(defmethod ctest/report ::summary
  [summary]
  (ctest/with-test-out
    (newline)
    (printf "Generative tests passed with seed %s:\n" (:seed summary))
    ; TODO: better formatting
    (prn summary)))


;; Report the shrunk value of a failed test summary.
(defmethod ctest/report ::shrunk
  [summary]
  (ctest/with-test-out
    (newline)
    (printf "Tests failed with seed %s - smallest case:\n" (:seed summary))
    ; TODO: more shrink stats
    (prn (dissoc (:shrunk summary) :smallest))
    (let [[context op-seqs] (get-in summary [:shrunk :smallest])]
      (newline)
      (println "Context:")
      (puget/cprint context)
      (newline)
      (println "Operation sequences:")
      (doseq [ops op-seqs]
        (puget/cprint ops)))
    (newline)
    (println "Result:")
    (let [result (get-in summary [:shrunk :result])]
      (if (instance? Throwable result)
        (clojure.stacktrace/print-cause-trace result)
        (puget/cprint result)))))
