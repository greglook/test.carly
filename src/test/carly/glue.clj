(ns test.carly.glue
  "Integration code for wedding generative `test.check` functions and
  `clojure.test` assertion macros."
  (:require
    [clojure.test :as ctest]
    [clojure.test.check :as tc]
    [clojure.test.check.generators :as gen]
    [puget.printer :as puget]))


; TODO: affordance for setting pretty-printer handlers


;; ## Helper Functions

(defmacro capture-reports
  "Capture any clojure.test reports generated by the body. Returns a vector
  containing the evaluated result, followed by a vector of reports."
  [& body]
  `(let [reports# (atom [])]
     [(binding [ctest/report (partial swap! reports# conj)]
        ~@body)
      @reports#]))


(defn publish!
  "Publish a collection of reports to clojure.test."
  [reports]
  (run! ctest/report reports))


(defn ^:no-doc wrap-report-check
  "Wrap the given sequence of forms such that it returns false if there is a
  failed clojure.test assertion in the body. If there are no assertions,
  returns the result of evaluating the body."
  [body]
  `(let [[result# reports#] (capture-reports ~@body)]
     (publish! reports#)
     (if (empty? reports#)
       result#
       (not (some (comp #{:fail :error} :type) reports#)))))



;; ## Test Property

(defn- apply-test
  "Helper to produce a property by applying the test function to a realized
  set of arguments from some bound generator."
  [function]
  (fn [args]
    (let [reports (atom [])
          result (try
                   (binding [ctest/report (partial swap! reports conj)]
                     (apply function args))
                   (catch ThreadDeath td
                     (throw td))
                   (catch Throwable ex
                     ex))]
      {:result result
       :function function
       ; XXX: Super gross, but we need to do this to get results through
       ; until test.check 0.10.0. ಠ_ಠ
       :args (vary-meta args assoc ::reports @reports)})))


(defn- report-summary-result
  "Emit clojure.test reports for the summarized results of the generative
  tests."
  [result]
  (if (:result result)
    ; TODO: report summary
    (ctest/is (not (instance? Throwable (:result result))) result)
    (ctest/with-test-out
      (ctest/report (-> result (dissoc :result) (assoc :type ::shrunk)))
      (publish! (:reports result)))))


(defn ^:no-doc check-system*
  "Helper function to wrap a testing function with generative checking and
  reporting logic. See `check-and-report`."
  [num-tests-or-options gen-inputs f]
  (let [opts (cond
               (map? num-tests-or-options)
                 num-tests-or-options
               (integer? num-tests-or-options)
                 {:num-tests num-tests-or-options})]
    (report-summary-result
      (apply tc/quick-check
        (:num-tests opts 10)
        (gen/fmap
          (apply-test f)
          gen-inputs)
        (apply concat (dissoc opts :num-tests))))))


(defmacro check-and-report
  "Macro to wrap a `clojure.test/testing` block around the system check."
  [message options gen-inputs f]
  `(ctest/testing ~message
     (check-system* ~options ~gen-inputs ~f)))












;;;;; REVIEW BELOW THIS LINE ;;;;;

;; Report a successful generative test summary.
(defmethod ctest/report ::summary
  [summary]
  (newline)
  (printf "Generative tests passed with seed %s:\n" (:seed summary))
  ; TODO: better formatting
  (prn summary))


;; Report the shrunk value of a failed test summary.
(defmethod ctest/report ::shrunk
  [summary]
  (newline)
  (printf "Tests failed with seed %s - smallest case:\n" (:seed summary))
  ; TODO: more shrink stats
  (prn (dissoc (:shrunk summary) :smallest))
  (puget/cprint (get-in summary [:shrunk :smallest])))


(defn report-filter
  "Test reporting function which silently counts simple result types :pass, :fail,
  and :error as namespace variants, and calls report-fn with all others."
  [report-fn report]
  (case (:type report)
    (:pass :fail :error) (ctest/inc-report-counter :pass)
    (report-fn report)))
